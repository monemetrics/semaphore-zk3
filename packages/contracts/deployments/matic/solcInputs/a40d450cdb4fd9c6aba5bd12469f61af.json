{
  "language": "Solidity",
  "sources": {
    "contracts/extensions/SemaphoreZk3.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"../interfaces/ISemaphoreZk3.sol\";\nimport \"../base/SemaphoreGroups.sol\";\nimport \"../interfaces/ISemaphoreVerifier.sol\";\n\n/// @title SemaphoreZK3 circles contract.\n/// @dev The following code allows you to create circles, add members and allow them to double signal.\ncontract SemaphoreZk3 is Initializable, ISemaphoreZk3, SemaphoreGroups {\n    /// @dev Gets a tree depth and returns its verifier address.\n    ISemaphoreVerifier internal verifier;\n\n    address public deployer;\n    address public governance;\n\n    /// @dev Gets a circle id and returns the circle data.\n    mapping(uint256 => Circle) internal circles;\n\n\n    constructor() {\n        _disableInitializers();\n        // verifier = _verifier;\n    }\n\n    /// @dev Checks if the circle coordinator is the transaction sender.\n    /// @param circleId: Id of the circle.\n    modifier onlyCoordinator(uint256 circleId) {\n        if (circles[circleId].coordinator != _msgSender()) {\n            revert Semaphore__CallerIsNotCoordinator();\n        }\n\n        _;\n    }\n\n    modifier onlyGovernance() {\n        if (governance != _msgSender()) {\n            revert Zk3__CallerIsNotGovernance();\n        }\n\n        _;\n    }\n\n    modifier onlyDeployer() {\n        if (deployer != _msgSender()) {\n            revert Zk3__CallerIsNotOwner();\n        }\n\n        _;\n    }\n\n    function initialize(ISemaphoreVerifier _verifier) public initializer {\n        verifier = _verifier;\n        deployer = _msgSender();\n        governance = _msgSender();\n    }\n\n    function setGovernance(address _governance) public onlyDeployer {\n        address currentGovernance = governance;\n        governance = _governance;\n\n        emit GovernanceUpdated(currentGovernance, _governance);\n    }\n    \n\n    /// @dev See {ISemaphoreZk3-createcircle}.\n    function createCircle(\n        uint256 circleId,\n        address coordinator,\n        uint256 merkleTreeDepth,\n        string calldata contentURI\n    ) public override onlyGovernance {\n        if (merkleTreeDepth < 16 || merkleTreeDepth > 32) {\n            revert Semaphore__MerkleTreeDepthIsNotSupported();\n        }\n\n        if (circles[circleId].coordinator != address(0)) {\n            revert Semaphore__GroupAlreadyExists();\n        }\n\n        _createGroup(circleId, merkleTreeDepth);\n\n        circles[circleId].coordinator = coordinator;\n        // don't store the nullifier hash so we can double spend the same note for now\n        circles[circleId].doubleSpend = true;\n        circles[circleId].contentURI = contentURI;\n\n        emit CircleCreated(circleId, coordinator, contentURI);\n    }\n\n    /// @dev See {ISemaphoreZk3-addVoter}.\n    function addIdentity(\n        uint256 circleId,\n        uint256 identityCommitment,\n        string calldata contentURI\n    ) public override onlyCoordinator(circleId) {\n        _addMember(circleId, identityCommitment);\n        updateContentURI(circleId, contentURI);\n    }\n\n    function revokeIdentity(\n        uint256 circleId,\n        uint256 identityCommitment,\n        uint256[] calldata proofSiblings,\n        uint8[] calldata proofPathIndices,\n        string calldata contentURI\n    ) public override onlyCoordinator(circleId) {\n        _removeMember(circleId, identityCommitment, proofSiblings, proofPathIndices);\n        updateContentURI(circleId, contentURI);\n    }\n\n    function updateContentURI(uint256 circleId, string calldata contentURI) public override onlyCoordinator(circleId) {\n        circles[circleId].contentURI = contentURI;\n        // todo: make sure the contentURI is valid and doesn't equal the current one.\n        // (assuming it's content addressable)\n        emit CircleURIUpdated(circleId, contentURI);\n    }\n\n    function getContentURI(uint256 circleId) public view virtual override returns (string memory) {\n        return circles[circleId].contentURI;\n    }\n\n    /// @dev See {ISemaphoreZk3-broadcastSignal}.\n    function broadcastSignal(\n        uint256 signal,\n        uint256 nullifierHash,\n        uint256 circleId,\n        uint256 externalNullifier,\n        uint256[8] calldata proof\n    ) public override {\n        // note this will only revert if the doubleSpend flag is false even if the nullifierHash is already used\n        if (circles[circleId].doubleSpend == false && circles[circleId].nullifierHashes[nullifierHash]) {\n            revert Semaphore__YouAreUsingTheSameNillifierTwice();\n        }\n\n        uint256 merkleTreeDepth = getMerkleTreeDepth(circleId);\n        uint256 merkleTreeRoot = getMerkleTreeRoot(circleId);\n\n        verifier.verifyProof(merkleTreeRoot, nullifierHash, signal, externalNullifier, proof, merkleTreeDepth);\n\n        circles[circleId].nullifierHashes[nullifierHash] = true;\n\n        emit MembershipVerified(circleId, signal, proof);\n    }\n\n    /// @dev See {ISemaphoreZk3-isValidProof}.\n    function isValidProof(\n        uint256 signal,\n        uint256 nullifierHash,\n        uint256 circleId,\n        uint256 externalNullifier,\n        uint256[8] calldata proof\n    ) public view virtual override returns (bool) {\n        uint256 merkleTreeDepth = getMerkleTreeDepth(circleId);\n        uint256 merkleTreeRoot = getMerkleTreeRoot(circleId);\n\n        verifier.verifyProof(merkleTreeRoot, nullifierHash, signal, externalNullifier, proof, merkleTreeDepth);\n        return true;\n    }\n}\n"
    },
    "contracts/interfaces/ISemaphoreZk3.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\n/// @title SemaphoreVoting interface.\n/// @dev Interface of SemaphoreVoting contract.\ninterface ISemaphoreZk3 {\n    error Semaphore__CallerIsNotCoordinator();\n    error Semaphore__MerkleTreeDepthIsNotSupported();\n    error Semaphore__YouAreUsingTheSameNillifierTwice();\n    error Zk3__CallerIsNotGovernance();\n    error Zk3__CallerIsNotOwner();\n\n    struct Circle {\n        address coordinator;\n        string contentURI;\n        bool doubleSpend;\n        mapping(uint256 => bool) nullifierHashes;\n    }\n\n    event GovernanceUpdated(address previousGovernance, address newGovernance);\n\n    /// @dev Emitted when a new group is created.\n    /// @param circleId: Id of the group.\n    /// @param coordinator: Coordinator of the group.\n    /// @param contentURI: the contentURI.\n    event CircleCreated(uint256 circleId, address indexed coordinator, string contentURI);\n\n    /// @dev Emitted when a user verifies their membership.\n    /// @param circleId: Id of the group.\n    /// @param signal: the signal verified.\n    /// @param proof: the proof.\n    event MembershipVerified(uint256 indexed circleId, uint256 signal, uint256[8] proof);\n\n    /// @dev Emitted when a coordinator updateds the URI for a circle.\n    /// @param circleId: Id of the group.\n    /// @param contentURI: the contentURI.\n    event CircleURIUpdated(uint256 indexed circleId, string contentURI);\n\n    /// @dev Creates a poll and the associated Merkle tree/group.\n    /// @param circleId: Id of the group.\n    /// @param coordinator: Coordinator of the poll.\n    /// @param merkleTreeDepth: Depth of the tree.\n    function createCircle(\n        uint256 circleId,\n        address coordinator,\n        uint256 merkleTreeDepth,\n        string calldata contentURI\n    ) external;\n\n    function updateContentURI(uint256 circleId, string calldata contentURI) external;\n\n    /// @dev Adds a user to a group.\n    /// @param circleId: Id of the group.\n    /// @param identityCommitment: Identity commitment of the group member.\n    function addIdentity(\n        uint256 circleId,\n        uint256 identityCommitment,\n        string calldata contentURI\n    ) external;\n\n    /// @dev removes a user from a gorup.\n    /// @param circleId: Id of the group.\n    /// @param identityCommitment: Identity commitment of the group member.\n    function revokeIdentity(\n        uint256 circleId,\n        uint256 identityCommitment,\n        uint256[] calldata proofSiblings,\n        uint8[] calldata proofPathIndices,\n        string calldata contentURI\n    ) external;\n\n    function getContentURI(uint256 circleId) external view returns (string memory);\n\n    /// @dev verify an identity membership in a circle.\n    /// @param signal: signal.\n    /// @param nullifierHash: Nullifier hash.\n    /// @param circleId: Id of the group.\n    /// @param externalNullifier: External nullifier.\n    /// @param proof: Private zk-proof parameters.\n    function broadcastSignal(\n        uint256 signal,\n        uint256 nullifierHash,\n        uint256 circleId,\n        uint256 externalNullifier,\n        uint256[8] calldata proof\n    ) external;\n\n    /// @dev verify an identity membership in a circle.\n    /// @param signal: signal.\n    /// @param nullifierHash: Nullifier hash.\n    /// @param circleId: Id of the group.\n    /// @param externalNullifier: External nullifier.\n    /// @param proof: Private zk-proof parameters.\n    function isValidProof(\n        uint256 signal,\n        uint256 nullifierHash,\n        uint256 circleId,\n        uint256 externalNullifier,\n        uint256[8] calldata proof\n    ) external view returns (bool);\n}\n"
    },
    "contracts/base/SemaphoreGroups.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"../interfaces/ISemaphoreGroups.sol\";\nimport \"@zk-kit/incremental-merkle-tree.sol/IncrementalBinaryTree.sol\";\n// import \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\n\n/// @title Semaphore groups contract.\n/// @dev This contract allows you to create groups, add, remove and update members.\n/// You can use getters to obtain informations about groups (root, depth, number of leaves).\nabstract contract SemaphoreGroups is ContextUpgradeable, ISemaphoreGroups {\n    using IncrementalBinaryTree for IncrementalTreeData;\n\n    /// @dev Gets a group id and returns the tree data.\n    mapping(uint256 => IncrementalTreeData) internal merkleTrees;\n\n    /// @dev Creates a new group by initializing the associated tree.\n    /// @param groupId: Id of the group.\n    /// @param merkleTreeDepth: Depth of the tree.\n    function _createGroup(uint256 groupId, uint256 merkleTreeDepth) internal virtual {\n        if (getMerkleTreeDepth(groupId) != 0) {\n            revert Semaphore__GroupAlreadyExists();\n        }\n\n        // The zeroValue is an implicit member of the group, or an implicit leaf of the Merkle tree.\n        // Although there is a remote possibility that the preimage of\n        // the hash may be calculated, using this value we aim to minimize the risk.\n        uint256 zeroValue = uint256(keccak256(abi.encodePacked(groupId))) >> 8;\n\n        merkleTrees[groupId].init(merkleTreeDepth, zeroValue);\n\n        emit GroupCreated(groupId, merkleTreeDepth, zeroValue);\n    }\n\n    /// @dev Adds an identity commitment to an existing group.\n    /// @param groupId: Id of the group.\n    /// @param identityCommitment: New identity commitment.\n    function _addMember(uint256 groupId, uint256 identityCommitment) internal virtual {\n        if (getMerkleTreeDepth(groupId) == 0) {\n            revert Semaphore__GroupDoesNotExist();\n        }\n\n        merkleTrees[groupId].insert(identityCommitment);\n\n        uint256 merkleTreeRoot = getMerkleTreeRoot(groupId);\n        uint256 index = getNumberOfMerkleTreeLeaves(groupId) - 1;\n\n        emit MemberAdded(groupId, index, identityCommitment, merkleTreeRoot);\n    }\n\n    /// @dev Updates an identity commitment of an existing group. A proof of membership is\n    /// needed to check if the node to be updated is part of the tree.\n    /// @param groupId: Id of the group.\n    /// @param identityCommitment: Existing identity commitment to be updated.\n    /// @param newIdentityCommitment: New identity commitment.\n    /// @param proofSiblings: Array of the sibling nodes of the proof of membership.\n    /// @param proofPathIndices: Path of the proof of membership.\n    function _updateMember(\n        uint256 groupId,\n        uint256 identityCommitment,\n        uint256 newIdentityCommitment,\n        uint256[] calldata proofSiblings,\n        uint8[] calldata proofPathIndices\n    ) internal virtual {\n        if (getMerkleTreeDepth(groupId) == 0) {\n            revert Semaphore__GroupDoesNotExist();\n        }\n\n        merkleTrees[groupId].update(identityCommitment, newIdentityCommitment, proofSiblings, proofPathIndices);\n\n        uint256 merkleTreeRoot = getMerkleTreeRoot(groupId);\n        uint256 index = proofPathIndicesToMemberIndex(proofPathIndices);\n\n        emit MemberUpdated(groupId, index, identityCommitment, newIdentityCommitment, merkleTreeRoot);\n    }\n\n    /// @dev Removes an identity commitment from an existing group. A proof of membership is\n    /// needed to check if the node to be deleted is part of the tree.\n    /// @param groupId: Id of the group.\n    /// @param identityCommitment: Existing identity commitment to be removed.\n    /// @param proofSiblings: Array of the sibling nodes of the proof of membership.\n    /// @param proofPathIndices: Path of the proof of membership.\n    function _removeMember(\n        uint256 groupId,\n        uint256 identityCommitment,\n        uint256[] calldata proofSiblings,\n        uint8[] calldata proofPathIndices\n    ) internal virtual {\n        if (getMerkleTreeDepth(groupId) == 0) {\n            revert Semaphore__GroupDoesNotExist();\n        }\n\n        merkleTrees[groupId].remove(identityCommitment, proofSiblings, proofPathIndices);\n\n        uint256 merkleTreeRoot = getMerkleTreeRoot(groupId);\n        uint256 index = proofPathIndicesToMemberIndex(proofPathIndices);\n\n        emit MemberRemoved(groupId, index, identityCommitment, merkleTreeRoot);\n    }\n\n    /// @dev See {ISemaphoreGroups-getMerkleTreeRoot}.\n    function getMerkleTreeRoot(uint256 groupId) public view virtual override returns (uint256) {\n        return merkleTrees[groupId].root;\n    }\n\n    /// @dev See {ISemaphoreGroups-getMerkleTreeDepth}.\n    function getMerkleTreeDepth(uint256 groupId) public view virtual override returns (uint256) {\n        return merkleTrees[groupId].depth;\n    }\n\n    /// @dev See {ISemaphoreGroups-getNumberOfMerkleTreeLeaves}.\n    function getNumberOfMerkleTreeLeaves(uint256 groupId) public view virtual override returns (uint256) {\n        return merkleTrees[groupId].numberOfLeaves;\n    }\n\n    /// @dev Converts the path indices of a Merkle proof to the identity commitment index in the tree.\n    /// @param proofPathIndices: Path of the proof of membership.\n    /// @return Index of a group member.\n    function proofPathIndicesToMemberIndex(uint8[] calldata proofPathIndices) private pure returns (uint256) {\n        uint256 memberIndex = 0;\n\n        for (uint8 i = uint8(proofPathIndices.length); i > 0; ) {\n            if (memberIndex > 0 || proofPathIndices[i - 1] != 0) {\n                memberIndex *= 2;\n\n                if (proofPathIndices[i - 1] == 1) {\n                    memberIndex += 1;\n                }\n            }\n\n            unchecked {\n                --i;\n            }\n        }\n\n        return memberIndex;\n    }\n}\n"
    },
    "contracts/interfaces/ISemaphoreVerifier.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"../base/Pairing.sol\";\n\n/// @title SemaphoreVerifier contract interface.\ninterface ISemaphoreVerifier {\n    struct VerificationKey {\n        Pairing.G1Point alfa1;\n        Pairing.G2Point beta2;\n        Pairing.G2Point gamma2;\n        Pairing.G2Point delta2;\n        Pairing.G1Point[] IC;\n    }\n\n    struct Proof {\n        Pairing.G1Point A;\n        Pairing.G2Point B;\n        Pairing.G1Point C;\n    }\n\n    /// @dev Verifies whether a Semaphore proof is valid.\n    /// @param merkleTreeRoot: Root of the Merkle tree.\n    /// @param nullifierHash: Nullifier hash.\n    /// @param signal: Semaphore signal.\n    /// @param externalNullifier: External nullifier.\n    /// @param proof: Zero-knowledge proof.\n    /// @param merkleTreeDepth: Depth of the tree.\n    function verifyProof(\n        uint256 merkleTreeRoot,\n        uint256 nullifierHash,\n        uint256 signal,\n        uint256 externalNullifier,\n        uint256[8] calldata proof,\n        uint256 merkleTreeDepth\n    ) external view;\n}\n"
    },
    "contracts/interfaces/ISemaphoreGroups.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\n/// @title SemaphoreGroups contract interface.\ninterface ISemaphoreGroups {\n    error Semaphore__GroupDoesNotExist();\n    error Semaphore__GroupAlreadyExists();\n\n    /// @dev Emitted when a new group is created.\n    /// @param groupId: Id of the group.\n    /// @param merkleTreeDepth: Depth of the tree.\n    /// @param zeroValue: Zero value of the tree.\n    event GroupCreated(uint256 indexed groupId, uint256 merkleTreeDepth, uint256 zeroValue);\n\n    /// @dev Emitted when a new identity commitment is added.\n    /// @param groupId: Group id of the group.\n    /// @param index: Identity commitment index.\n    /// @param identityCommitment: New identity commitment.\n    /// @param merkleTreeRoot: New root hash of the tree.\n    event MemberAdded(uint256 indexed groupId, uint256 index, uint256 identityCommitment, uint256 merkleTreeRoot);\n\n    /// @dev Emitted when an identity commitment is updated.\n    /// @param groupId: Group id of the group.\n    /// @param index: Identity commitment index.\n    /// @param identityCommitment: Existing identity commitment to be updated.\n    /// @param newIdentityCommitment: New identity commitment.\n    /// @param merkleTreeRoot: New root hash of the tree.\n    event MemberUpdated(\n        uint256 indexed groupId,\n        uint256 index,\n        uint256 identityCommitment,\n        uint256 newIdentityCommitment,\n        uint256 merkleTreeRoot\n    );\n\n    /// @dev Emitted when a new identity commitment is removed.\n    /// @param groupId: Group id of the group.\n    /// @param index: Identity commitment index.\n    /// @param identityCommitment: Existing identity commitment to be removed.\n    /// @param merkleTreeRoot: New root hash of the tree.\n    event MemberRemoved(uint256 indexed groupId, uint256 index, uint256 identityCommitment, uint256 merkleTreeRoot);\n\n    /// @dev Returns the last root hash of a group.\n    /// @param groupId: Id of the group.\n    /// @return Root hash of the group.\n    function getMerkleTreeRoot(uint256 groupId) external view returns (uint256);\n\n    /// @dev Returns the depth of the tree of a group.\n    /// @param groupId: Id of the group.\n    /// @return Depth of the group tree.\n    function getMerkleTreeDepth(uint256 groupId) external view returns (uint256);\n\n    /// @dev Returns the number of tree leaves of a group.\n    /// @param groupId: Id of the group.\n    /// @return Number of tree leaves.\n    function getNumberOfMerkleTreeLeaves(uint256 groupId) external view returns (uint256);\n}\n"
    },
    "@zk-kit/incremental-merkle-tree.sol/IncrementalBinaryTree.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {PoseidonT3} from \"./Hashes.sol\";\n\n// Each incremental tree has certain properties and data that will\n// be used to add new leaves.\nstruct IncrementalTreeData {\n    uint256 depth; // Depth of the tree (levels - 1).\n    uint256 root; // Root hash of the tree.\n    uint256 numberOfLeaves; // Number of leaves of the tree.\n    mapping(uint256 => uint256) zeroes; // Zero hashes used for empty nodes (level -> zero hash).\n    // The nodes of the subtrees used in the last addition of a leaf (level -> [left node, right node]).\n    mapping(uint256 => uint256[2]) lastSubtrees; // Caching these values is essential to efficient appends.\n}\n\n/// @title Incremental binary Merkle tree.\n/// @dev The incremental tree allows to calculate the root hash each time a leaf is added, ensuring\n/// the integrity of the tree.\nlibrary IncrementalBinaryTree {\n    uint8 internal constant MAX_DEPTH = 32;\n    uint256 internal constant SNARK_SCALAR_FIELD =\n        21888242871839275222246405745257275088548364400416034343698204186575808495617;\n\n    /// @dev Initializes a tree.\n    /// @param self: Tree data.\n    /// @param depth: Depth of the tree.\n    /// @param zero: Zero value to be used.\n    function init(\n        IncrementalTreeData storage self,\n        uint256 depth,\n        uint256 zero\n    ) public {\n        require(zero < SNARK_SCALAR_FIELD, \"IncrementalBinaryTree: leaf must be < SNARK_SCALAR_FIELD\");\n        require(depth > 0 && depth <= MAX_DEPTH, \"IncrementalBinaryTree: tree depth must be between 1 and 32\");\n\n        self.depth = depth;\n\n        for (uint8 i = 0; i < depth; ) {\n            self.zeroes[i] = zero;\n            zero = PoseidonT3.poseidon([zero, zero]);\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        self.root = zero;\n    }\n\n    /// @dev Inserts a leaf in the tree.\n    /// @param self: Tree data.\n    /// @param leaf: Leaf to be inserted.\n    function insert(IncrementalTreeData storage self, uint256 leaf) public {\n        uint256 depth = self.depth;\n\n        require(leaf < SNARK_SCALAR_FIELD, \"IncrementalBinaryTree: leaf must be < SNARK_SCALAR_FIELD\");\n        require(self.numberOfLeaves < 2**depth, \"IncrementalBinaryTree: tree is full\");\n\n        uint256 index = self.numberOfLeaves;\n        uint256 hash = leaf;\n\n        for (uint8 i = 0; i < depth; ) {\n            if (index & 1 == 0) {\n                self.lastSubtrees[i] = [hash, self.zeroes[i]];\n            } else {\n                self.lastSubtrees[i][1] = hash;\n            }\n\n            hash = PoseidonT3.poseidon(self.lastSubtrees[i]);\n            index >>= 1;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        self.root = hash;\n        self.numberOfLeaves += 1;\n    }\n\n    /// @dev Updates a leaf in the tree.\n    /// @param self: Tree data.\n    /// @param leaf: Leaf to be updated.\n    /// @param newLeaf: New leaf.\n    /// @param proofSiblings: Array of the sibling nodes of the proof of membership.\n    /// @param proofPathIndices: Path of the proof of membership.\n    function update(\n        IncrementalTreeData storage self,\n        uint256 leaf,\n        uint256 newLeaf,\n        uint256[] calldata proofSiblings,\n        uint8[] calldata proofPathIndices\n    ) public {\n        require(newLeaf != leaf, \"IncrementalBinaryTree: new leaf cannot be the same as the old one\");\n        require(newLeaf < SNARK_SCALAR_FIELD, \"IncrementalBinaryTree: new leaf must be < SNARK_SCALAR_FIELD\");\n        require(\n            verify(self, leaf, proofSiblings, proofPathIndices),\n            \"IncrementalBinaryTree: leaf is not part of the tree\"\n        );\n\n        uint256 depth = self.depth;\n        uint256 hash = newLeaf;\n        uint256 updateIndex;\n\n        for (uint8 i = 0; i < depth; ) {\n            updateIndex |= uint256(proofPathIndices[i]) << uint256(i);\n\n            if (proofPathIndices[i] == 0) {\n                if (proofSiblings[i] == self.lastSubtrees[i][1]) {\n                    self.lastSubtrees[i][0] = hash;\n                }\n\n                hash = PoseidonT3.poseidon([hash, proofSiblings[i]]);\n            } else {\n                if (proofSiblings[i] == self.lastSubtrees[i][0]) {\n                    self.lastSubtrees[i][1] = hash;\n                }\n\n                hash = PoseidonT3.poseidon([proofSiblings[i], hash]);\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n        require(updateIndex < self.numberOfLeaves, \"IncrementalBinaryTree: leaf index out of range\");\n\n        self.root = hash;\n    }\n\n    /// @dev Removes a leaf from the tree.\n    /// @param self: Tree data.\n    /// @param leaf: Leaf to be removed.\n    /// @param proofSiblings: Array of the sibling nodes of the proof of membership.\n    /// @param proofPathIndices: Path of the proof of membership.\n    function remove(\n        IncrementalTreeData storage self,\n        uint256 leaf,\n        uint256[] calldata proofSiblings,\n        uint8[] calldata proofPathIndices\n    ) public {\n        update(self, leaf, self.zeroes[0], proofSiblings, proofPathIndices);\n    }\n\n    /// @dev Verify if the path is correct and the leaf is part of the tree.\n    /// @param self: Tree data.\n    /// @param leaf: Leaf to be removed.\n    /// @param proofSiblings: Array of the sibling nodes of the proof of membership.\n    /// @param proofPathIndices: Path of the proof of membership.\n    /// @return True or false.\n    function verify(\n        IncrementalTreeData storage self,\n        uint256 leaf,\n        uint256[] calldata proofSiblings,\n        uint8[] calldata proofPathIndices\n    ) private view returns (bool) {\n        require(leaf < SNARK_SCALAR_FIELD, \"IncrementalBinaryTree: leaf must be < SNARK_SCALAR_FIELD\");\n        uint256 depth = self.depth;\n        require(\n            proofPathIndices.length == depth && proofSiblings.length == depth,\n            \"IncrementalBinaryTree: length of path is not correct\"\n        );\n\n        uint256 hash = leaf;\n\n        for (uint8 i = 0; i < depth; ) {\n            require(\n                proofSiblings[i] < SNARK_SCALAR_FIELD,\n                \"IncrementalBinaryTree: sibling node must be < SNARK_SCALAR_FIELD\"\n            );\n\n            require(\n                proofPathIndices[i] == 1 || proofPathIndices[i] == 0,\n                \"IncrementalBinaryTree: path index is neither 0 nor 1\"\n            );\n\n            if (proofPathIndices[i] == 0) {\n                hash = PoseidonT3.poseidon([hash, proofSiblings[i]]);\n            } else {\n                hash = PoseidonT3.poseidon([proofSiblings[i], hash]);\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return hash == self.root;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@zk-kit/incremental-merkle-tree.sol/Hashes.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nlibrary PoseidonT3 {\n    function poseidon(uint256[2] memory) public pure returns (uint256) {}\n}\n\nlibrary PoseidonT6 {\n    function poseidon(uint256[5] memory) public pure returns (uint256) {}\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "contracts/base/Pairing.sol": {
      "content": "// Copyright 2017 Christian Reitwiessner\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n// The following Pairing library is a modified version adapted to Semaphore.\n//\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nlibrary Pairing {\n    error Semaphore__InvalidProof();\n\n    // The prime q in the base field F_q for G1\n    uint256 constant BASE_MODULUS = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    // The prime moludus of the scalar field of G1.\n    uint256 constant SCALAR_MODULUS = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n\n    struct G1Point {\n        uint256 X;\n        uint256 Y;\n    }\n\n    // Encoding of field elements is: X[0] * z + X[1]\n    struct G2Point {\n        uint256[2] X;\n        uint256[2] Y;\n    }\n\n    /// @return the generator of G1\n    function P1() public pure returns (G1Point memory) {\n        return G1Point(1, 2);\n    }\n\n    /// @return the generator of G2\n    function P2() public pure returns (G2Point memory) {\n        return\n            G2Point(\n                [\n                    11559732032986387107991004021392285783925812861821192530917403151452391805634,\n                    10857046999023057135944570762232829481370756359578518086990519993285655852781\n                ],\n                [\n                    4082367875863433681332203403145435568316851327593401208105741076214120093531,\n                    8495653923123431417604973247489272438418190587263600148770280649306958101930\n                ]\n            );\n    }\n\n    /// @return r the negation of p, i.e. p.addition(p.negate()) should be zero.\n    function negate(G1Point memory p) public pure returns (G1Point memory r) {\n        if (p.X == 0 && p.Y == 0) {\n            return G1Point(0, 0);\n        }\n\n        // Validate input or revert\n        if (p.X >= BASE_MODULUS || p.Y >= BASE_MODULUS) {\n            revert Semaphore__InvalidProof();\n        }\n\n        // We know p.Y > 0 and p.Y < BASE_MODULUS.\n        return G1Point(p.X, BASE_MODULUS - p.Y);\n    }\n\n    /// @return r the sum of two points of G1\n    function addition(G1Point memory p1, G1Point memory p2) public view returns (G1Point memory r) {\n        // By EIP-196 all input is validated to be less than the BASE_MODULUS and form points\n        // on the curve.\n        uint256[4] memory input;\n\n        input[0] = p1.X;\n        input[1] = p1.Y;\n        input[2] = p2.X;\n        input[3] = p2.Y;\n\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 6, input, 0xc0, r, 0x60)\n        }\n\n        if (!success) {\n            revert Semaphore__InvalidProof();\n        }\n    }\n\n    /// @return r the product of a point on G1 and a scalar, i.e.\n    /// p == p.scalar_mul(1) and p.addition(p) == p.scalar_mul(2) for all points p.\n    function scalar_mul(G1Point memory p, uint256 s) public view returns (G1Point memory r) {\n        // By EIP-196 the values p.X and p.Y are verified to less than the BASE_MODULUS and\n        // form a valid point on the curve. But the scalar is not verified, so we do that explicitelly.\n        if (s >= SCALAR_MODULUS) {\n            revert Semaphore__InvalidProof();\n        }\n\n        uint256[3] memory input;\n\n        input[0] = p.X;\n        input[1] = p.Y;\n        input[2] = s;\n\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 7, input, 0x80, r, 0x60)\n        }\n\n        if (!success) {\n            revert Semaphore__InvalidProof();\n        }\n    }\n\n    /// Asserts the pairing check\n    /// e(p1[0], p2[0]) *  .... * e(p1[n], p2[n]) == 1\n    /// For example pairing([P1(), P1().negate()], [P2(), P2()]) should succeed\n    function pairingCheck(G1Point[] memory p1, G2Point[] memory p2) public view {\n        // By EIP-197 all input is verified to be less than the BASE_MODULUS and form elements in their\n        // respective groups of the right order.\n        if (p1.length != p2.length) {\n            revert Semaphore__InvalidProof();\n        }\n\n        uint256 elements = p1.length;\n        uint256 inputSize = elements * 6;\n        uint256[] memory input = new uint256[](inputSize);\n\n        for (uint256 i = 0; i < elements; i++) {\n            input[i * 6 + 0] = p1[i].X;\n            input[i * 6 + 1] = p1[i].Y;\n            input[i * 6 + 2] = p2[i].X[0];\n            input[i * 6 + 3] = p2[i].X[1];\n            input[i * 6 + 4] = p2[i].Y[0];\n            input[i * 6 + 5] = p2[i].Y[1];\n        }\n\n        uint256[1] memory out;\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 8, add(input, 0x20), mul(inputSize, 0x20), out, 0x20)\n        }\n\n        if (!success || out[0] != 1) {\n            revert Semaphore__InvalidProof();\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}